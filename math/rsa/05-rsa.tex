\section{RSA}

Now we finally begin to define RSA. The idea is to choose three numbers:

\begin{itemize}
  \item
    The encryption exponent $e$.
  \item
    The decryption exponent $d$.
  \item
    The modulus $n$.
\end{itemize}

We want to select $e, d, n$ such that:

\begin{nedqn}
  \parens{m^e}^d
\eqcol
  m \mod n
\end{nedqn}

\subsection{Choosing $p, q, n$}

You choose big primes $p$ and $q$. These can be randomly sampled. How do
you know a random choice of $p$ or $q$ is prime? It is slow to test
conclusively (though it is polytime).

Faster is to use an application of Fermat's little theorem. If $p$ is
prime, then for every random choice of $a$, we must have that $a^p = a
\mod p$. Selecting lots of choices of $a$ gives us confidence that $p$
is prime.

There is also the Miller-Rabin test; I don't know exactly how that is
done. It is again a randomized Monte Carlo algorithm with a probability
of failure.

It is also suggested that you can first quickly pre-filter non-primes by
testing with division by common small prime factors. Then you move on to
Fermat, then to Miller-Rabin.

Once you have selected $p, q$ that are almost certainly prime, you
then let your modulus be $n = pq$.

\subsection{Criteria for selecting $e, d$}

Euler's totient theorem says:

\begin{nedqn}
  m^{\varphi(n)}
\eqcol
  1 \mod n
\end{nedqn}

Recall that we want to choose decryption exponents $e, d$ such that:

\begin{nedqn}
  \parens{m^e}^d
\eqcol
  m \mod n
\end{nedqn}

Therefore, we would like that $ed = k \varphi(n) + 1$ (for whatever
integer $k$). Put another way, we want:

\begin{nedqn}
  ed
\eqcol
  1 \mod \varphi(n)
\end{nedqn}

\subsection{Calculating $\varphi(n)$ when $p, q$ are known}

\begin{lemma}
  \begin{nedqn}
    \varphi(n)
  \eqcol
    (p - 1) (q - 1)
  \end{nedqn}
\end{lemma}

\begin{proof}
  Let's consider numbers that are \emph{not} coprime to $n$. They must
  be:

  \begin{IEEEeqnarray*}{c}
    1p, 2p, \ldots, (q - 1)p
  \\
    1q, 2q, \ldots, (p - 1)q
  \\
    pq
  \end{IEEEeqnarray*}

  Let's think about this. We start with $pq$ numbers $1, \ldots, n$. We
  remove the multiples of $p$ (including $pq$). There are $q$ of these.
  That leaves us with $(p - 1)q$ candidate coprime numbers less than
  $n$.

  Next we remove the multiples of $q$. There are $p - 1$ of them; this
  time we do not remove $pq$. We've already removed that one.

  Thus a total of $(p - 1) (q - 1)$ numbers remain. All these are
  coprime to $n$.

  Thus $\varphi(n) = (p - 1)(q - 1)$.
\end{proof}

\begin{remark}
  Note that we can now rephrase our requirement for $e, d$ more
  precisely. We want:

  \begin{nedqn}
    ed
  \eqcol
    1 \mod (p - 1) (q - 1)
  \end{nedqn}
\end{remark}

\begin{remark}
  Note that we have shown how it is easy to calculate $\varphi(n)$ when
  the factors $p, q$ are known. Calculating $\varphi(n)$ when $p, q$ are
  \emph{not} known could be very challenging!
\end{remark}

\subsection{Choosing $e$}

First, choose any $e$ coprime to $(p - 1) (q - 1)$. We need $e$ to be
coprime to $\varphi(n)$ since we will also want to find a $d = \inv{e}$.

$e = 3$ is a common choice for fast encryption. Because $e = 3$ could be
a factor of $(p - 1)(q - 1)$, you might need to start over.

Sometimes you might now want $e = 3$ because it might not ``wrap $m$
around'' $n$ enough. If you view exponentiation as ``scrambling,'' a
large $e$ does more ``scrambling.'' For that reason, $e = 65,537$ is
also a common choice.

\subsection{Calculating $d$}

We must next choose $d$ to be the inverse of $e$ mod $(p - 1) (q - 1)$.

How do we invert $e$? This is an application of the extended Euclidean
algorithm. I describe that algorithm in another document. The extended
Euclidean algorithm is efficient and fast.

\subsection{Security assumptions}

\begin{remark}
  After generation of $n, e, d$, there is no need to retain $p, q$. We
  will want to destroy those. To encrypt $m^e \bmod n$, the encryptor
  needs only the pair $(e, n)$. To decrypt $\parens{m^e}^d \bmod n$, the
  decryptor needs the pair $(d, n)$.
\end{remark}

\begin{remark}
  We want to make sure that $d$ cannot be recovered easily if we only
  know the public key $(e, n)$.

  We saw that if we know how to factor $n$, we know how to calculate
  $\varphi(n)$, and thus it is easy to invert $e \bmod \varphi(n)$ (via
  the extended Euclidean algorithm) to find $d$. Indeed, that is exactly
  how we derived $d$ when generating the keypair.

  Therefore, the security of RSA presumes the difficulty of factoring
  $n$.
\end{remark}

\begin{remark}
  If we don't know how to factor $n$, then we presume that it is hard to
  calculate $\varphi(n)$ any other way. The security of RSA presumes
  this.

  Likewise, we presume that it is hard to find $d$ without calculating
  $\varphi(n)$.

  Last, we assume that it is hard to calculate $m$ from $m^e \bmod n$
  without calculating $d$.
\end{remark}

\begin{remark}
  It is worth noting: inverting $e \bmod n$ (using $n$ instead of
  $\varphi(n)$) does not help you calculate $m$ from $m^e \bmod n$.

  That is, say you calculate $d'$ such that $e d' = 1 \mod n$. Then it
  is \emph{not} true that you can argue:

  \begin{nedqn}
    \parens{m^e}^{d'}
  \eqcol
    m^{ed'}
    \mod n
  \\
  \eqcol
    m^{ed' \bmod n}
    \mod n
    \nedcomment{wrong!}
  \\
  \eqcol
    m^1
  \end{nedqn}

  The point is: it doesn't help to invert $e \bmod n$. That would be
  easy given the public key $(e, n)$ (by the extended Euclidean
  algorithm), but it's not what you need. You need to invert with
  respect to $\varphi(n)$, and the point is that it's supposed to be
  hard to calculate $\varphi(n)$ without the factors of $n$.

  % Basically, mods don't work in exponents. Here's an example ($a = 123$):

  %     101 ^ 8 % 123 = 109
  %     101 ^ {246 + 8} % 123 = 32
\end{remark}

\begin{remark}
  Note: we can't encrypt any message $m$ that is not in the
  multiplicative group of $\Zmodn$ (because otherwise Euler's totient
  theorem doesn't apply). But the number of such messages $n -
  \varphi(n)$ is tiny relative to $n$. Anyway the tester can always
  easily find $\gcd(m, n)$ to verify they are relatively prime.
\end{remark}

\begin{remark}
  Euler's $\varphi(n)$ is not always the least number $x$ such that $m^x
  = 1 \mod n$ for all $m$ values (in the multiplicative group). That
  value is called \define{Carmichael's lambda function}. It is smaller
  and more specific. Of course, we must always have that $\varphi(n)$ is
  always a multiple of $\lambda(n)$ (because Euler's totient theorem
  always applies).

  If it were commonly the case that $\lambda(n)$ were significantly
  smaller than $\varphi(n)$, that would have security implications for
  RSA. It would mean a brute-force search for $\lambda(n)$ would be more
  likely to succeed, if we expected to search in a much smaller range.

  However, I think almost always $\lambda(n) = \varphi(n)$.
\end{remark}
